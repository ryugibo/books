---
title: 노마드코더 북클럽 실용주의 프로그래머 TIL 다섯번째
date: '2022-03-27'
tags: ['노마드코더', '북클럽', '책', 'TIL']
draft: false
summary: 5장 구부러지거나 부러지거나
images: []
layout: PostLayout
canonicalUrl:
---

2022년 3월 26일 TIL

## 오늘 TIL 3줄 요약

- 유한 상태 기계 (`Finite State Machine`)를 적극 활용하자.
- 상속은 사용하지 말고, 인스턴스를 사용하는 별개 클래스를 작성하자.
- 입력을 출력으로 바꾸는 기본적인 사고방식에 집중해서 결합을 줄이자.

## 오늘 읽은 범위

- 5장. 구부러지거나 부러지거나 (206/477) ~ (265/477)

## 책에서 기억하고 싶은 내용을 써보세요.

- 문지 말고 말하라. Tell Don't Ask. TDA. (211/477)
- 여러분의 코드에 있는 것이 싱글턴뿐이더라도, 외부로 노출된 언스턴스 변수가 잔뜩 있는 싱글턴은 여전히 전역 데이터이다. 그저 이름이 좀 길어졌을 뿐이다. (216/477)
- 외부 리소스도 전역 데이터이다. 여기서 해법은 반드시 이 리소스들을 여러분이 작성하는 코드로 모두 감싸는 것이다. (216/477)
- 상태 기계는 개발자들에게 저평가되어 있다. 여러분이 상태 기계를 적용할 수 있는 곳을 한번 찾아보면 좋겠다. (224/477)
- 당신이 원한 것은 바나나 하나였지만, 당신이 받은 것은 바나나를 들고 있는 고릴라와 정글 전체다. (249/477)
- 객체 지향 언어로 프로그래밍하는가? 상속을 사용하는가? 그렇다면 멈춰라! 아마 여러분에게 필요한 것은 상속이 아닐 것이다. (249/477)
- 서비스에 위임하라. `Has-A`가 `Is-A`보다 낫다. (257/477)

## 오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요

- `Elixir`에 대한 내용..
  - 간단한 코드는 `Ruby`나 `Ruby on Rails` 코드가 예제로 쓰는 경우가 많은데 조금 최근의 패러다임? 을 반영하는 코드는 `Elixir` 코드를 사용하는 부분이 많아보인다.
  - `|>` 파이프 연산자를 참여했던 프로젝트에서는 주로 `GenServer`에서 유지되는 `state`를 변경하는데에만 주로 사용했었는데.. 이유는 연속된 파이프 연산자를 거치면서 `List`가 정수로.. 정수가 문자열로.. 계속 데이터가 변경되면 다른 사람이 코드를 볼때 바로 이해하기 어려워지는 부분을 고려했던걸로 기억한다. 처음 `state`를 넣었으면 연속된 파이프 연산자가 끝난 이후에도 반환되는건 `state`가 반환되는 느낌이다. 근데 지금 생각해보면 파이프 연산자를 쓰지 않고 지역변수로 풀어서 작성했던 로직도 그렇게 가독성이 좋지는 않았던것 같다. 오히려 지역 변수에 값을 저장할때마다 새로 메모리가 할당되는 `Elixir` 특성상 비효율적이지 않았을까..?
  - 본문 코드를 보면 연속된 `static` 함수를 호출하는 형태인데 말그대로 객체지향에서는 파이프 연산자가 있으면 막상 필요한 부분이 없다고 느껴질 것 같다. `Elixir`에서는 함수가 모두 `static` 이기 때문에 `this` 포인터 대신 첫번째 매개변수를 넘긴다는 느낌이다.
  - 오류 처리 부분에서 튜플 패턴 매칭을 활용해서, 파이프 연산자에서 오류를 처리할 수 있는 부분은 괜찮아 보인다. 프로젝트 초기에 확실한 방향을 정해서 작업이 진행된다면.. 참여했던 프로젝트는 어디는 `with` 블럭을 사용하기도 하고 어떤 함수에서는 `{:ok, _}`를 반환하고 어떤 함수는 `:ok`만 반환하는 등 기준을 정하지 않고 다들 맘대로 작업해서 일관성이 없어서 좋지 않았던 것같다.
- 예전 프로젝트에서 게임 프로그래밍 패턴[^1] 책을 읽고 나서 옵저버 패턴을 적용했던 적이 있다. 당시에는 큰 문제는 없었지만 게시-구독 형태가 더 괜찮아보인다. 다음에 적용할 기회가 있다면 적용해봐야겠다. `Elixir`를 사용하는 경우엔 `GenServer` 사이에 `cast` 형태로 주고받는 메시지가 같은 내용일 것이다.
- X 언어에는 파이프라인이 없는데요..
  - 언리얼 엔진의 UI 프레임워크인 Slate 코드를 보다보면 `operator.`를 `this` 레퍼런스를 반환하도록 오버라이딩해서 특정 구조체나 클래스를 연속된 함수호출로 묶을 수 있게 정의되어있다. 그런식으로 하면 `C++`는 파이프 연산자처럼 만들 수 있기는 하다. 그러나 일반적인 게임 프로젝트에서는 UI는 UMG라는 기능을 한번 거쳐서 사용되기 때문에 Slate를 사용할 일은 없다.

## 궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.

- 믹스인(mixin): `java`에서 사용하는 `interface`와 같은 내용 같은데, 예제 코드들이 잘 이해되지 않아서 좀 더 찾아봐야겟다.

## 여담

- 생각보다 `Elixir`가 직접 언급되는 내용이 많아서 가물가물한 예전 작업 기억들을 더듬으면서 읽게 되는것 같다. 더 까먹기전에 `Elixir`로 뭐라도 만들어보는게 좋을지도..?

[^1]: 게임 프로그래밍 패턴 (한빛미디어), 9788968482878
